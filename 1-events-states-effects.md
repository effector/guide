## События, состояния, эффекты
* По своей сути, базовые сущности эффектора реализуют три больших паттерна
слайд: три больших вопроса обозначающим секции, разделенные двумя вертикальными полосками
* это ивент эмиттер и машина состояний
слайд: открываются первые два вопроса, первый вопрос становится окружностью, второй пустым квадратом

### Ивенты
слайд: в центре экрана пустой кружок, ниже подпись Event
* ивент эмиттер это самый распространённый паттерн в javascript
* он используется чтобы подписываться на события DOM-элементов, чтобы общаться с service worker’ами
* nodejs построена полностью на этом паттерне, буквально все асинхронные процессы
* ивент эмиттер обычно имеет два метода: subscribe и emit, иногда dispatch, send и так далее, методы можно назвать как угодно
* ведь главной задачей паттерна, является подписка:
```js
eventEmitter.subscribe('name-changed', (name) => console.log(name))
```
* вызов этих событий со значением:
```js
eventEmitter.emit('name-changed', 'Sergey Sova')
```
* И эффектор буквально реализует этот паттерн:
```js
const nameChanged = createEvent()
```
* Его можно вызывать
```js
nameChanged('Sergey Sova')
```
* И подписаться:
```js
nameChanged.subscribe((name) => console.log(name)
```
* На этом этапе, разница только в синтаксисе. Каждый ивент это объект с методами, созданный с помощью фабрики `createEvent`
* Вместо `subscribe` обычно используется `watch`, или же вообще другие методы, о которых расскажу позже
```js
nameChanged.watch((name) => console.log(name))
```
* Ну и конечно, можно отписаться от ивента:
```js
const unwatch = nameChanged.watch((name) => console.log(name)) 
nameChanged('Sergey Sova'); // => Sergey Sova
unwatch();
nameChanged('Wow'); // nothing
```
* У ивентов есть много полезных методов, расширяющих их применение, все их разберем в последующих выпусках
* Но это ещё не всё, ивент эмиттер это двунаправленное общение: один первый пользователь подписывается, а второй отсылает, но одновременно с этим, второй пользователь может подписаться на другие события, которые будет отсылать первый.
* Благодаря подобным возможностям, как отписка в процессе работы приложения, могут возникать различные проблемы, такие как утечка памяти и множественная подписка. Как такое решается в обычных ивент эмиттерах можно почитать тут [Неверное использование EventEmitter](http://dmenshikov.com/2017-06-09-incorrect-usage-of-event-emitter/)
* Эффектор же предлагает другой способ работы с событиями: *никогда от них не отписываться*.
* Предлагается построить логику так, чтобы отписка от событий не понадобилась вообще никогда, один из подходов это фильтрация событий. 
```js
const reallyChanged = nameChanged.filter({
  fn: (name) => name.length > 0
})
```
* При каждом срабатывании события `nameChanged`, эффектор вызовет функцию `fn` в `filter`. Если функция вернула `true` , то событие `reallyChanged` будет вызвано с тем же аргументом, что и `nameChanged`.
* Обратите внимание, что метод  `filter` создает *новое* событие, которое будет вызвано каждый раз, как пользователь меняет имя на валидное, если передаст невалидное, событие не будет вызвано, и дальнейшая логика будет пропущена. Вуаля! Отписываться от событий больше не нужно, а значит проблем с утечками можно избежать, построив такие связи заранее.
* Аналогичный подход можно использовать для трансформации аргумента:
```js
const usernameChanged = reallyChanged.map(
  (name) => name.toLowerCase().replaceAll(' ', '-')
)
```
* Метод `map`  здесь тоже создает новое событие.
* В предыдущем примере, с помощью `reallyChanged` мы удостоверились, что в него придет валидное имя, а значит можно запускать логику смены имени.
* В этом примере, нужно проставить новый username пользователю на основе его имени. Преобразуем в lowercase и дефисы вместо пробелов.
* Здесь логика даже проще: когда сработает `reallyChanged`, эффектор вызовет функцию переданную в `map` с аргументом от `reallyChanged`, видим там `name`. Затем, вызовет событие `usernameChanged` и передаст туда результат вызова функции, то есть получившийся username.
* Прошу отметить, что здесь получилась цепочка событий, которую можно записать буквально:
```js
import { createEvent } from 'effector';

const nameChanged = createEvent();
const usernameChanged = nameChanged
	.filter({ fn: (name) => name.length > 0 })
	.map((name) => name.toLowerCase().replaceAll(' ', '-'));
```
* Теперь можно подписаться на событие `usernameChanged`, вызвать `nameChanged` и поглядеть, что будет.
```js
usernameChanged.watch((username) => console.info(username));
nameChanged("Sergey Sova"); // => sergey-sova
```
* Предлагаю поставить видео на паузу и поиграться с этим кодом в Effector Playground — https://share.effector.dev/W9OZtvZg
